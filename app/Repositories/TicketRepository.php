<?php
/* 28.01.2026
 * Обрабатываем данные
 *
 * Вобше я насколько читал о репозиторий в восновном они только получает данные,
 * но я видел в ТЗ слова "Весь функцирнал разбить на классы ... " и по этой причине я предпологаю вам важно
 * иметь тонкий контроллер что кстати тоже есть упоминания о нем в ТЗ и вся логика разбита на части
 * тоесть каждый класс занимаеться своим функционалом - скажу вам честно у меня всегда так
 * я всегда группирую или как увас разбиваю это в будущем на разширяемость ох как влияет проверено горьким опытом :(
 *
 * Но здесь как я выше описал мне пришлось использовать создания иммено здесь потому что
 * в сервисе тоже не хочеться мусорить как то так.
 * **/
namespace App\Repositories;

use App\Models\Ticket;
use App\Models\Customer;
use Illuminate\Support\Carbon;
class TicketRepository
{
    /**
     * Проверка: есть ли заявка от email + phone за последние 24 часа
     * Тоесть при отправке заявки в таблицу записуеться - tickets.customer_email и tickets.customer_phone
     * теперь мы их и проверим.
     *
     * Данный метод способен обработать 2 варианта событий, я на будушее собрал:
     * Дело в том что тенденция уже больше к номеру телефона идет а почта как дополнительно
     * по этой причине 2 проверки становяться лишние и даже сечас,
     * но так как форма отправки и правила валидации заточены на обезательные поля
     * пока так но можно чтото закоментировать смело валидация не пропустит сюда.
     *
     * Я уже писал в таблице: database\migrations\0000_01_00_000002_create_tickets_table.php
     *
     * Метод вернет:
     * return true -> такая заявка уже была отправлена и сутки не прошли -> нужно блокировать нового клиента + новую заявку
     * return false -> заявок за сутки нет -> можно создавать новую заявку
     */
    public function existsLast24Hours(string $email, string $phone): bool
    {
        return Ticket::query()

            // можно один из методов закомментировать еcли только один в приоритете и только он
            // Обязателен как в валидации, так и в форме, но до этого момента если это так! Придется все изменить как выше я написал.
            // Мне пришлось так сделать так как в задании не сказан ни приоритет ни обязательное пол для заполнения.

            // Проерим есть ли заявка с такой почтой
            ->where('customer_email', $email)
            // Далее проверим а может есть с таким номером телефона
            ->where('customer_phone', $phone)

            /*
             * Вот здесь мы фильтруем заявки
             *
             * Если честно я думаю что заявку можно было бы отправлять раз вдень
             * но тогда едимственый минус я в конце строки пояснил
             * whereDate(..., Carbon::today()) календарные сутки вот минус если за день -> если отправит в 23:59 -> 00:01 то можно снова
             * ***/
            ->where('created_at', '>=', Carbon::now()->subDay())
            /*
             * Методом вернем true или false
             * булево значения
             * **/
            ->exists();
    }

    /*
     * Найти или создать клиента если его нет.
     * И создать заявку с привязкой к клиенту
     *
     * Так ребят я не увидел ни регистрации ни авторизации а это
     * значит клиент создаётся автоматически при заявке - это мое предположения.
     *
     * Вернет модель созданной заявки со всеми ее данными
     * **/
    public function createFromWidget(array $data): Ticket
    {
        // Найти или создать клиента
        $customer = Customer::firstOrCreate(
            [
                'email' => $data['email'],
                'phone' => $data['phone'],
            ],
            [
                'name' => $data['name'],
            ]
        );

        // Создать заявку
        // в низу есть метод storeTicket можно это удалить и воспользоваться им...
        return Ticket::create([
            'customer_id'    => $customer->id,
            'customer_email' => $customer->email,
            'customer_phone' => $customer->phone,
            'subject'        => $data['subject'],
            'message'        => $data['message'],
            'status'         => 'new',
        ]);
    }

    /*
     * Статистика заявок (сутки, неделя, месяц)
     *
     * ***/
    public function statistics(): array
    {
        return [
            'day'   => Ticket::lastDay()->count(),
            'week'  => Ticket::lastWeek()->count(),
            'month' => Ticket::lastMonth()->count(),
        ];
    }

    /*
     * Найти клиента по почте или номеру телефона
     *
     * return:
     *   Customer - если найден
     *   null - если нет
     *
     * ***/
    public function findCustomer(string $email, string $phone): ?Customer
    {
        return Customer::where('email', $email)
            ->where('phone', $phone)
            ->first();
    }

    /*
     * Создать заявку - если по правильному не собирать части логики в одном методе
     * **/
    public function storeTicket(Customer $customer, array $data): Ticket
    {
        return Ticket::create([
            'customer_id'    => $customer->id,
            'customer_email' => $customer->email,
            'customer_phone' => $customer->phone,
            'subject'        => $data['subject'],
            'message'        => $data['message'],
            'status'         => 'new',
        ]);
    }
}
