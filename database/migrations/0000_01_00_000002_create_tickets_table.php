<?php
// 24.01.2026 - это сами заявки (записи, которые создаёт клиент).
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
		Schema::create('tickets', function (Blueprint $table) {
            /*
             * Идентификатор - заявки
             * **/
            $table->id();

            /*
             * Ссылка на клиента
             * Здесь Идентификатор - customers.id
             * тоесть поле для связи между таблицами.
             * **/
            $table->foreignId('customer_id')
                  ->constrained('customers')         // Связуем с клинтом
                  ->cascadeOnDelete()                     // Удалить запись если клиент удален
                  ->index('idx_tickets_customer_id');     // Как всегда индекс так как выборка и все поиски по id клиента

            /*
             * Для антидублей и аналитики я сохраняю email и телефон клиента прямо в заявке как
             * бизнес-идентичность (идентификация),
             * чтобы ограничения не зависели от жизненного цикла аккаунта.
             *
             * В общем я в первый раз немного ошибся по логике не учел кое-чего и заново переделал
             * лучше сделаем дубли между таблицами, но железобетонно сработает.
             *
             * tickets.customer_email == customers.phone
             * tickets.customer_phone == customers.email
             *
             * Логика безопастности таже самая но я немного изменил чтобы было понятнее:
             *
             * 1. Клиент email + phone -> создаётся customers.id = 10
             * 2. Отправляет заявку
             * 3. Удаляет аккаунт -> запись в customers удалена
             * 4. Регистрируется снова -> customers.id = 25
             * 5. Отправляет заявку ещё раз (обход ограничения)
             * Ограничение "1 заявка в сутки" ОБОЙДЕНО!
             * И по этой причине опираться на customers.id = 10 опастно!
             *
             * Далее если вдруг все таки по не известной причине просроченая заявка не будет удалена
             * или в вашей логике есть на это причины я не добавляю ->unique(); уникальность.
             * Потому что если пользователь опять отправит заявку после установленого лимита напримере
             * тестового задания это сутки таблица изи ограничения не пропустит уже есть
             * такакя заявка с такой почтой или номером телефона.
             *
             * :)
             * И последнее я не знаю как у вас в планах будет чистка просроченных заявок например 2 варианта:
             * 1 - ну такое нужно руками удалять или установить в Cron
             * создаем -> app/Console/Commands/CleanExpiredTickets.php
             *
             * 2.
             * Мне нравиться этот вариант с планировшщиком:
             *
             * - На сервере добавляем одну строку для Cron: * * * * * cd /path/to/project && php artisan schedule:run >> /dev/null 2>&1
             *   запускаем разписания.
             * - И в C:\Projects\myshop-test\routes\console.php
             *  Это просто пример:
             *  Schedule::call(function () {
             *      \App\Models\Ticket::where('created_at', '<', now()->subDays(30))->delete();
             *  })->dailyAt('03:00');
             *
             *  Но для высоких нагрузок мое любимое :), много миллионов записей
             *  или еще нужно логировать/обрабатывать каждую запись отдельно или то и другое вместе
             *
             *  то первое нужно создать отдельный канал для job чтобы не забивать не основной или вдруг упадет не останавливать
             * процес.
             *
             * создаем очередь для нашей задачи -> app/Jobs/CleanExpiredTicketsJob.php
             * в ней: Ticket::where('created_at', '<', now()->subDays(30))->delete();
             *
             * Теперь планируем -> routes/console.php
             * Schedule::call(function () {
             *   -> отправляем нашу задачу в очередь, которую будет обрабатывать Horizon
             *   CleanExpiredTicketsJob::dispatch();
             * })->dailyAt('03:00'); -> каждый день в 03:00 утра или в 04 100% большенство спит сладким сном
             * проверено когда работал мастером и админил сайты :)
             *
             * Ну и Cron как же без него * * * * * cd /path/to/project && php artisan schedule:run >> /dev/null 2>&1
             *
             * Вобщем работает это так:
             *
             * Cron запускает schedule:run каждую минуту
             * Scheduler проверяет, что сейчас 03:00, и отправляет задачу в очередь.
             * Horizon обрабатывает задачуb, удаляя старые заявки.
             *
             * + еще можно для верочки в job добавить ели упал процес подныть там 1 или 3 раза а потом ошибка
             * я могу вечно писать как то так.
             *
             * в Итоге у нас получаеться если реально очень много заявок то лучше как я выше описал
             * отдельный канал так что никто ничего не затормазит и гарантия что все отработает + если упадет
             * процесс в цепочке я имею вв иду в job то Horizon попытаеться поднять что дает двойную гарантия
             * и у вас чистые БД без мертвых заявок и так далее.. :)
             **/

            /*
             * Здесь почта клиента - дублируем
             **/
            $table->string('customer_email', 50)->index('idx_tickets_customer_email');

            /*
             * Здесь номер телефона - дублируем
             **/
            $table->string('customer_phone', 20)->index('idx_tickets_customer_phone');

            /*
             * Тема: быстро понять, о чём заявка
             * */
            $table->string('subject', 150)->index('idx_tickets_subject');

            /*
             * Текст: полный текст от клиента я так предпологаю
             **/
            $table->text('message');

            /*
             * Статус: цыкл жизни например new -> in_progress -> completed
             * **/
            $table->enum('status', [
                'new',               // Новая заявка
                'in_progress',       // Заявка в обработке
                'completed'          // Заявка обработанна
            ])->default('new'); // При создании заявки установим поумолчанию новая заявка

            /*
             * Дата ответа от менеджера - !не путаем с обновлением статуса
             * **/
            $table->timestamp('answered_at')->nullable();

            /*
             * Для сортировки, фильтрации или даже можно как история
             **/
            $table->timestamps();

            /*
             * Составной индекс (оптимизация как я ранее говорил)
             * - можно фильтровать по статусу
             * - можно получить список заявок по статусу
             * - можно статус + период
             *
             * Под вашу тестовую задачу достаточно
             * Это главный индекс всей админки под менеджера, для админа я в тестовом задании не нашёл
             * **/
            $table->index(['status', 'created_at'], 'idx_tickets_status_created');

            /*
             * Для фильтрации по - дата заявки
             * - можно фильтровать по дате
             * - можно делать сортировку по дате
             * **/
            $table->index('created_at', 'idx_tickets_created_at');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('tickets');
    }
};
